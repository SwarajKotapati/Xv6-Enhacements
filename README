Section 3 : The third section delves into user
level thread management, adding a layer of sophistication to
 process execution within xv6. By implementing user-level
 threads, the assignment introduces a user-level threading
 library (ULTLib) responsible for thread creation, switching,
 yielding, and destruction. Various scheduling algorithms,
 including round-robin, first-come-first-serve, and priority
 scheduling, are incorporated, enhancing the multitasking
 capabilities of the operating system. Following are the task
 breakdowns for this assignment.
 User-Level
 Threading
 Library
 (ULTLib)Library
 Initialization: Upon initialization, a data structure (similar to
 proc in the kernel) is created to track each user-level thread.
 Assigned the first kernel-provided thread as the user-level
 scheduler thread within this structure. Implemented this
 initialization in the ulthread init() function.
 Thread Creation : To create a thread, the starting function
 address, initial arguments, stack location, thread priority, and
 a context save location is obtained from the user process
 using ulthread create(). Created and maintained the context
 save location in ULTLib. Updated the thread as RUNNABLE
 for scheduling.
 Thread Switch: The user-level scheduler thread is invoked
 to schedule threads after creation and each time a user-level
 thread yields its CPU. Implemented an assembly function to
 save the current thread’s registers and load registers from the
 next scheduled thread’s context. Initialized the registers for
 correct function argument passing.
 Thread Yield and Destroy : Implemented ulthread yield()
 for a thread to give up its execution, asking the scheduler
 to schedule a different thread. At the thread’s end,
 ulthread destroy() is called to signal completion. Worked on
 state changes to YIELD or FREE and perform necessary
 housekeeping tasks before switching back to the scheduler.
 Thread Scheduling Decisions : The user-level scheduler
 thread determines which thread to schedule based on round
robin, first-come-first-serve, or priority scheduling algorithms.
 A scheduler is developed that is aware of these algorithms,
 making decisions based on the specified policy during library
 initialization.
 Testing : Conducted testing for FCFS, Priority, and Round
 Robin scheduling algorithms. Rigorous testing, including
 corner situations, and designed additional test cases for
 thorough validation.


xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
Version 6 (v6).  xv6 loosely follows the structure and style of v6,
but is implemented for a modern RISC-V multiprocessor using ANSI C.

ACKNOWLEDGMENTS

xv6 is inspired by John Lions's Commentary on UNIX 6th Edition (Peer
to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
2000)).  See also https://pdos.csail.mit.edu/6.1810/, which provides
pointers to on-line resources for v6.

The following people have made contributions: Russ Cox (context switching,
locking), Cliff Frey (MP), Xiao Yu (MP), Nickolai Zeldovich, and Austin
Clements.

We are also grateful for the bug reports and patches contributed by
Takahiro Aoyagi, Silas Boyd-Wickizer, Anton Burtsev, carlclone, Ian
Chen, Dan Cross, Cody Cutler, Mike CAT, Tej Chajed, Asami Doi,
eyalz800, Nelson Elhage, Saar Ettinger, Alice Ferrazzi, Nathaniel
Filardo, flespark, Peter Froehlich, Yakir Goaron, Shivam Handa, Matt
Harvey, Bryan Henry, jaichenhengjie, Jim Huang, Matúš Jókay, John
Jolly, Alexander Kapshuk, Anders Kaseorg, kehao95, Wolfgang Keller,
Jungwoo Kim, Jonathan Kimmitt, Eddie Kohler, Vadim Kolontsov, Austin
Liew, l0stman, Pavan Maddamsetti, Imbar Marinescu, Yandong Mao, Matan
Shabtay, Hitoshi Mitake, Carmi Merimovich, Mark Morrissey, mtasm, Joel
Nider, Hayato Ohhashi, OptimisticSide, Harry Porter, Greg Price, Jude
Rich, segfault, Ayan Shafqat, Eldar Sehayek, Yongming Shen, Fumiya
Shigemitsu, Cam Tenny, tyfkda, Warren Toomey, Stephen Tu, Rafael Ubal,
Amane Uehara, Pablo Ventura, Xi Wang, WaheedHafez, Keiichi Watanabe,
Nicolas Wolovick, wxdao, Grant Wu, Jindong Zhang, Icenowy Zheng,
ZhUyU1997, and Zou Chang Wei.


The code in the files that constitute xv6 is
Copyright 2006-2022 Frans Kaashoek, Robert Morris, and Russ Cox.

ERROR REPORTS

Please send errors and suggestions to Frans Kaashoek and Robert Morris
(kaashoek,rtm@mit.edu).  The main purpose of xv6 is as a teaching
operating system for MIT's 6.1810, so we are more interested in
simplifications and clarifications than new features.

BUILDING AND RUNNING XV6

You will need a RISC-V "newlib" tool chain from
https://github.com/riscv/riscv-gnu-toolchain, and qemu compiled for
riscv64-softmmu.  Once they are installed, and in your shell
search path, you can run "make qemu".
